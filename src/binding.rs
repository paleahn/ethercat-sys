/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const EC_END: i32 = -1;
pub const EC_MAX_SYNC_MANAGERS: u32 = 16;
pub const EC_MAX_STRING_LENGTH: u32 = 64;
pub const EC_MAX_PORTS: u32 = 4;
pub const EC_COE_EMERGENCY_MSG_SIZE: u32 = 8;
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of in_addr"][::std::mem::size_of::<in_addr>() - 4usize];
    ["Alignment of in_addr"][::std::mem::align_of::<in_addr>() - 4usize];
    ["Offset of field: in_addr::s_addr"][::std::mem::offset_of!(in_addr, s_addr) - 0usize];
};
#[doc = " Data types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_master {
    _unused: [u8; 0],
}
pub type ec_master_t = ec_master;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_slave_config {
    _unused: [u8; 0],
}
pub type ec_slave_config_t = ec_slave_config;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_domain {
    _unused: [u8; 0],
}
pub type ec_domain_t = ec_domain;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_sdo_request {
    _unused: [u8; 0],
}
pub type ec_sdo_request_t = ec_sdo_request;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_soe_request {
    _unused: [u8; 0],
}
pub type ec_soe_request_t = ec_soe_request;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_voe_handler {
    _unused: [u8; 0],
}
pub type ec_voe_handler_t = ec_voe_handler;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_reg_request {
    _unused: [u8; 0],
}
pub type ec_reg_request_t = ec_reg_request;
#[doc = " Master state.\n\n This is used for the output parameter of ecrt_master_state().\n\n \\see ecrt_master_state()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ec_master_state_t {
    #[doc = "< Sum of responding slaves on all\nEthernet devices."]
    pub slaves_responding: ::std::os::raw::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_master_state_t"][::std::mem::size_of::<ec_master_state_t>() - 8usize];
    ["Alignment of ec_master_state_t"][::std::mem::align_of::<ec_master_state_t>() - 4usize];
    ["Offset of field: ec_master_state_t::slaves_responding"]
        [::std::mem::offset_of!(ec_master_state_t, slaves_responding) - 0usize];
};
impl ec_master_state_t {
    #[inline]
    pub fn al_states(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_al_states(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn al_states_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_al_states_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_up(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link_up(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_up_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_link_up_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        al_states: ::std::os::raw::c_uint,
        link_up: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let al_states: u32 = unsafe { ::std::mem::transmute(al_states) };
            al_states as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let link_up: u32 = unsafe { ::std::mem::transmute(link_up) };
            link_up as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Redundant link state.\n\n This is used for the output parameter of ecrt_master_link_state().\n\n \\see ecrt_master_link_state()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ec_master_link_state_t {
    #[doc = "< Sum of responding slaves on the given\nlink."]
    pub slaves_responding: ::std::os::raw::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_master_link_state_t"][::std::mem::size_of::<ec_master_link_state_t>() - 8usize];
    ["Alignment of ec_master_link_state_t"]
        [::std::mem::align_of::<ec_master_link_state_t>() - 4usize];
    ["Offset of field: ec_master_link_state_t::slaves_responding"]
        [::std::mem::offset_of!(ec_master_link_state_t, slaves_responding) - 0usize];
};
impl ec_master_link_state_t {
    #[inline]
    pub fn al_states(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_al_states(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn al_states_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_al_states_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_up(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link_up(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_up_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_link_up_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        al_states: ::std::os::raw::c_uint,
        link_up: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let al_states: u32 = unsafe { ::std::mem::transmute(al_states) };
            al_states as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let link_up: u32 = unsafe { ::std::mem::transmute(link_up) };
            link_up as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Slave configuration state.\n\n This is used as an output parameter of ecrt_slave_config_state().\n\n \\see ecrt_slave_config_state()."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct ec_slave_config_state_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_slave_config_state_t"][::std::mem::size_of::<ec_slave_config_state_t>() - 4usize];
    ["Alignment of ec_slave_config_state_t"]
        [::std::mem::align_of::<ec_slave_config_state_t>() - 4usize];
};
impl ec_slave_config_state_t {
    #[inline]
    pub fn online(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_online(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn online_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_online_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn operational(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_operational(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn operational_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_operational_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn al_state(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_al_state(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn al_state_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_al_state_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        online: ::std::os::raw::c_uint,
        operational: ::std::os::raw::c_uint,
        al_state: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let online: u32 = unsafe { ::std::mem::transmute(online) };
            online as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let operational: u32 = unsafe { ::std::mem::transmute(operational) };
            operational as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let al_state: u32 = unsafe { ::std::mem::transmute(al_state) };
            al_state as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Master information.\n\n This is used as an output parameter of ecrt_master().\n\n \\see ecrt_master()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ec_master_info_t {
    #[doc = "< Number of slaves in the network."]
    pub slave_count: ::std::os::raw::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< \\a true, while the master is scanning the network."]
    pub scan_busy: u8,
    #[doc = "< Application time."]
    pub app_time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_master_info_t"][::std::mem::size_of::<ec_master_info_t>() - 16usize];
    ["Alignment of ec_master_info_t"][::std::mem::align_of::<ec_master_info_t>() - 8usize];
    ["Offset of field: ec_master_info_t::slave_count"]
        [::std::mem::offset_of!(ec_master_info_t, slave_count) - 0usize];
    ["Offset of field: ec_master_info_t::scan_busy"]
        [::std::mem::offset_of!(ec_master_info_t, scan_busy) - 5usize];
    ["Offset of field: ec_master_info_t::app_time"]
        [::std::mem::offset_of!(ec_master_info_t, app_time) - 8usize];
};
impl ec_master_info_t {
    #[inline]
    pub fn link_up(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link_up(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_up_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_link_up_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(link_up: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link_up: u32 = unsafe { ::std::mem::transmute(link_up) };
            link_up as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Master scan progress information.\n\n This is used as an output parameter of ecrt_master_scan_progress().\n\n \\see ecrt_master_scan_progress()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ec_master_scan_progress_t {
    #[doc = "< Number of slaves detected."]
    pub slave_count: ::std::os::raw::c_uint,
    #[doc = "< Index of the slave that is currently\nscanned.  If it is less than the \\a\nslave_count, the network scan is in progress."]
    pub scan_index: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_master_scan_progress_t"]
        [::std::mem::size_of::<ec_master_scan_progress_t>() - 8usize];
    ["Alignment of ec_master_scan_progress_t"]
        [::std::mem::align_of::<ec_master_scan_progress_t>() - 4usize];
    ["Offset of field: ec_master_scan_progress_t::slave_count"]
        [::std::mem::offset_of!(ec_master_scan_progress_t, slave_count) - 0usize];
    ["Offset of field: ec_master_scan_progress_t::scan_index"]
        [::std::mem::offset_of!(ec_master_scan_progress_t, scan_index) - 4usize];
};
#[repr(u32)]
#[doc = " EtherCAT slave port descriptor."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ec_slave_port_desc_t {
    #[doc = "< Port is not implemented."]
    EC_PORT_NOT_IMPLEMENTED = 0,
    #[doc = "< Port is not configured."]
    EC_PORT_NOT_CONFIGURED = 1,
    #[doc = "< Port is an E-Bus."]
    EC_PORT_EBUS = 2,
    #[doc = "< Port is a MII."]
    EC_PORT_MII = 3,
}
#[doc = " EtherCAT slave port information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ec_slave_port_link_t {
    #[doc = "< Link detected."]
    pub link_up: u8,
    #[doc = "< Loop closed."]
    pub loop_closed: u8,
    #[doc = "< Detected signal on RX port."]
    pub signal_detected: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_slave_port_link_t"][::std::mem::size_of::<ec_slave_port_link_t>() - 3usize];
    ["Alignment of ec_slave_port_link_t"][::std::mem::align_of::<ec_slave_port_link_t>() - 1usize];
    ["Offset of field: ec_slave_port_link_t::link_up"]
        [::std::mem::offset_of!(ec_slave_port_link_t, link_up) - 0usize];
    ["Offset of field: ec_slave_port_link_t::loop_closed"]
        [::std::mem::offset_of!(ec_slave_port_link_t, loop_closed) - 1usize];
    ["Offset of field: ec_slave_port_link_t::signal_detected"]
        [::std::mem::offset_of!(ec_slave_port_link_t, signal_detected) - 2usize];
};
#[doc = " Slave information.\n\n This is used as an output parameter of ecrt_master_get_slave().\n\n \\see ecrt_master_get_slave()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_slave_info_t {
    #[doc = "< Offset of the slave in the ring."]
    pub position: u16,
    #[doc = "< Vendor-ID stored on the slave."]
    pub vendor_id: u32,
    #[doc = "< Product-Code stored on the slave."]
    pub product_code: u32,
    #[doc = "< Revision-Number stored on the slave."]
    pub revision_number: u32,
    #[doc = "< Serial-Number stored on the slave."]
    pub serial_number: u32,
    #[doc = "< The slaves alias if not equal to 0."]
    pub alias: u16,
    #[doc = "< Used current in mA."]
    pub current_on_ebus: i16,
    #[doc = "< Port information."]
    pub ports: [ec_slave_info_t__bindgen_ty_1; 4usize],
    #[doc = "< Current state of the slave."]
    pub al_state: u8,
    #[doc = "< Error flag for that slave."]
    pub error_flag: u8,
    #[doc = "< Number of sync managers."]
    pub sync_count: u8,
    #[doc = "< Number of SDOs."]
    pub sdo_count: u16,
    #[doc = "< Name of the slave."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_slave_info_t__bindgen_ty_1 {
    #[doc = "< Physical port type."]
    pub desc: ec_slave_port_desc_t,
    #[doc = "< Port link state."]
    pub link: ec_slave_port_link_t,
    #[doc = "< Receive time on DC transmission delay\nmeasurement."]
    pub receive_time: u32,
    #[doc = "< Ring position of next DC slave on that\nport."]
    pub next_slave: u16,
    #[doc = "< Delay [ns] to next DC slave."]
    pub delay_to_next_dc: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_slave_info_t__bindgen_ty_1"]
        [::std::mem::size_of::<ec_slave_info_t__bindgen_ty_1>() - 20usize];
    ["Alignment of ec_slave_info_t__bindgen_ty_1"]
        [::std::mem::align_of::<ec_slave_info_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: ec_slave_info_t__bindgen_ty_1::desc"]
        [::std::mem::offset_of!(ec_slave_info_t__bindgen_ty_1, desc) - 0usize];
    ["Offset of field: ec_slave_info_t__bindgen_ty_1::link"]
        [::std::mem::offset_of!(ec_slave_info_t__bindgen_ty_1, link) - 4usize];
    ["Offset of field: ec_slave_info_t__bindgen_ty_1::receive_time"]
        [::std::mem::offset_of!(ec_slave_info_t__bindgen_ty_1, receive_time) - 8usize];
    ["Offset of field: ec_slave_info_t__bindgen_ty_1::next_slave"]
        [::std::mem::offset_of!(ec_slave_info_t__bindgen_ty_1, next_slave) - 12usize];
    ["Offset of field: ec_slave_info_t__bindgen_ty_1::delay_to_next_dc"]
        [::std::mem::offset_of!(ec_slave_info_t__bindgen_ty_1, delay_to_next_dc) - 16usize];
};
impl Default for ec_slave_info_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_slave_info_t"][::std::mem::size_of::<ec_slave_info_t>() - 176usize];
    ["Alignment of ec_slave_info_t"][::std::mem::align_of::<ec_slave_info_t>() - 4usize];
    ["Offset of field: ec_slave_info_t::position"]
        [::std::mem::offset_of!(ec_slave_info_t, position) - 0usize];
    ["Offset of field: ec_slave_info_t::vendor_id"]
        [::std::mem::offset_of!(ec_slave_info_t, vendor_id) - 4usize];
    ["Offset of field: ec_slave_info_t::product_code"]
        [::std::mem::offset_of!(ec_slave_info_t, product_code) - 8usize];
    ["Offset of field: ec_slave_info_t::revision_number"]
        [::std::mem::offset_of!(ec_slave_info_t, revision_number) - 12usize];
    ["Offset of field: ec_slave_info_t::serial_number"]
        [::std::mem::offset_of!(ec_slave_info_t, serial_number) - 16usize];
    ["Offset of field: ec_slave_info_t::alias"]
        [::std::mem::offset_of!(ec_slave_info_t, alias) - 20usize];
    ["Offset of field: ec_slave_info_t::current_on_ebus"]
        [::std::mem::offset_of!(ec_slave_info_t, current_on_ebus) - 22usize];
    ["Offset of field: ec_slave_info_t::ports"]
        [::std::mem::offset_of!(ec_slave_info_t, ports) - 24usize];
    ["Offset of field: ec_slave_info_t::al_state"]
        [::std::mem::offset_of!(ec_slave_info_t, al_state) - 104usize];
    ["Offset of field: ec_slave_info_t::error_flag"]
        [::std::mem::offset_of!(ec_slave_info_t, error_flag) - 105usize];
    ["Offset of field: ec_slave_info_t::sync_count"]
        [::std::mem::offset_of!(ec_slave_info_t, sync_count) - 106usize];
    ["Offset of field: ec_slave_info_t::sdo_count"]
        [::std::mem::offset_of!(ec_slave_info_t, sdo_count) - 108usize];
    ["Offset of field: ec_slave_info_t::name"]
        [::std::mem::offset_of!(ec_slave_info_t, name) - 110usize];
};
impl Default for ec_slave_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " Domain working counter interpretation.\n\n This is used in ec_domain_state_t."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ec_wc_state_t {
    #[doc = "< No registered process data were exchanged."]
    EC_WC_ZERO = 0,
    #[doc = "< Some of the registered process data were\nexchanged."]
    EC_WC_INCOMPLETE = 1,
    #[doc = "< All registered process data were exchanged."]
    EC_WC_COMPLETE = 2,
}
#[doc = " Domain state.\n\n This is used for the output parameter of ecrt_domain_state()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_domain_state_t {
    #[doc = "< Value of the last working counter."]
    pub working_counter: ::std::os::raw::c_uint,
    #[doc = "< Working counter interpretation."]
    pub wc_state: ec_wc_state_t,
    #[doc = "< Redundant link is in use."]
    pub redundancy_active: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_domain_state_t"][::std::mem::size_of::<ec_domain_state_t>() - 12usize];
    ["Alignment of ec_domain_state_t"][::std::mem::align_of::<ec_domain_state_t>() - 4usize];
    ["Offset of field: ec_domain_state_t::working_counter"]
        [::std::mem::offset_of!(ec_domain_state_t, working_counter) - 0usize];
    ["Offset of field: ec_domain_state_t::wc_state"]
        [::std::mem::offset_of!(ec_domain_state_t, wc_state) - 4usize];
    ["Offset of field: ec_domain_state_t::redundancy_active"]
        [::std::mem::offset_of!(ec_domain_state_t, redundancy_active) - 8usize];
};
impl Default for ec_domain_state_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " Direction type for PDO assignment functions."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ec_direction_t {
    #[doc = "< Invalid direction. Do not use this value."]
    EC_DIR_INVALID = 0,
    #[doc = "< Values written by the master."]
    EC_DIR_OUTPUT = 1,
    #[doc = "< Values read by the master."]
    EC_DIR_INPUT = 2,
    #[doc = "< Number of directions. For internal use only."]
    EC_DIR_COUNT = 3,
}
#[repr(u32)]
#[doc = " Watchdog mode for sync manager configuration.\n\n Used to specify, if a sync manager's watchdog is to be enabled."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ec_watchdog_mode_t {
    #[doc = "< Use the default setting of the sync manager."]
    EC_WD_DEFAULT = 0,
    #[doc = "< Enable the watchdog."]
    EC_WD_ENABLE = 1,
    #[doc = "< Disable the watchdog."]
    EC_WD_DISABLE = 2,
}
#[doc = " PDO entry configuration information.\n\n This is the data type of the \\a entries field in ec_pdo_info_t.\n\n \\see ecrt_slave_config_pdos()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ec_pdo_entry_info_t {
    #[doc = "< PDO entry index."]
    pub index: u16,
    #[doc = "< PDO entry subindex."]
    pub subindex: u8,
    #[doc = "< Size of the PDO entry in bit."]
    pub bit_length: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_pdo_entry_info_t"][::std::mem::size_of::<ec_pdo_entry_info_t>() - 4usize];
    ["Alignment of ec_pdo_entry_info_t"][::std::mem::align_of::<ec_pdo_entry_info_t>() - 2usize];
    ["Offset of field: ec_pdo_entry_info_t::index"]
        [::std::mem::offset_of!(ec_pdo_entry_info_t, index) - 0usize];
    ["Offset of field: ec_pdo_entry_info_t::subindex"]
        [::std::mem::offset_of!(ec_pdo_entry_info_t, subindex) - 2usize];
    ["Offset of field: ec_pdo_entry_info_t::bit_length"]
        [::std::mem::offset_of!(ec_pdo_entry_info_t, bit_length) - 3usize];
};
#[doc = " PDO configuration information.\n\n This is the data type of the \\a pdos field in ec_sync_info_t.\n\n \\see ecrt_slave_config_pdos()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_pdo_info_t {
    #[doc = "< PDO index."]
    pub index: u16,
    #[doc = "< Number of PDO entries in \\a entries to map.\nZero means, that the default mapping shall be\nused (this can only be done if the slave is\npresent at configuration time)."]
    pub n_entries: ::std::os::raw::c_uint,
    #[doc = "< Array of PDO entries to map. Can\neither be \\a NULL, or must contain\nat least \\a n_entries values."]
    pub entries: *const ec_pdo_entry_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_pdo_info_t"][::std::mem::size_of::<ec_pdo_info_t>() - 16usize];
    ["Alignment of ec_pdo_info_t"][::std::mem::align_of::<ec_pdo_info_t>() - 8usize];
    ["Offset of field: ec_pdo_info_t::index"]
        [::std::mem::offset_of!(ec_pdo_info_t, index) - 0usize];
    ["Offset of field: ec_pdo_info_t::n_entries"]
        [::std::mem::offset_of!(ec_pdo_info_t, n_entries) - 4usize];
    ["Offset of field: ec_pdo_info_t::entries"]
        [::std::mem::offset_of!(ec_pdo_info_t, entries) - 8usize];
};
impl Default for ec_pdo_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Sync manager configuration information.\n\n This can be use to configure multiple sync managers including the PDO\n assignment and PDO mapping. It is used as an input parameter type in\n ecrt_slave_config_pdos()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_sync_info_t {
    #[doc = "< Sync manager index. Must be less\nthan #EC_MAX_SYNC_MANAGERS for a valid sync manager,\nbut can also be \\a 0xff to mark the end of the list."]
    pub index: u8,
    #[doc = "< Sync manager direction."]
    pub dir: ec_direction_t,
    #[doc = "< Number of PDOs in \\a pdos."]
    pub n_pdos: ::std::os::raw::c_uint,
    #[doc = "< Array with PDOs to assign. This must\ncontain at least \\a n_pdos PDOs."]
    pub pdos: *const ec_pdo_info_t,
    #[doc = "< Watchdog mode."]
    pub watchdog_mode: ec_watchdog_mode_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_sync_info_t"][::std::mem::size_of::<ec_sync_info_t>() - 32usize];
    ["Alignment of ec_sync_info_t"][::std::mem::align_of::<ec_sync_info_t>() - 8usize];
    ["Offset of field: ec_sync_info_t::index"]
        [::std::mem::offset_of!(ec_sync_info_t, index) - 0usize];
    ["Offset of field: ec_sync_info_t::dir"][::std::mem::offset_of!(ec_sync_info_t, dir) - 4usize];
    ["Offset of field: ec_sync_info_t::n_pdos"]
        [::std::mem::offset_of!(ec_sync_info_t, n_pdos) - 8usize];
    ["Offset of field: ec_sync_info_t::pdos"]
        [::std::mem::offset_of!(ec_sync_info_t, pdos) - 16usize];
    ["Offset of field: ec_sync_info_t::watchdog_mode"]
        [::std::mem::offset_of!(ec_sync_info_t, watchdog_mode) - 24usize];
};
impl Default for ec_sync_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " List record type for PDO entry mass-registration.\n\n This type is used for the array parameter of the\n ecrt_domain_reg_pdo_entry_list()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_pdo_entry_reg_t {
    #[doc = "< Slave alias address."]
    pub alias: u16,
    #[doc = "< Slave position."]
    pub position: u16,
    #[doc = "< Slave vendor ID."]
    pub vendor_id: u32,
    #[doc = "< Slave product code."]
    pub product_code: u32,
    #[doc = "< PDO entry index."]
    pub index: u16,
    #[doc = "< PDO entry subindex."]
    pub subindex: u8,
    #[doc = "< Pointer to a variable to store the PDO entry's\n(byte-)offset in the process data."]
    pub offset: *mut ::std::os::raw::c_uint,
    #[doc = "< Pointer to a variable to store a bit\nposition (0-7) within the \\a offset. Can be\nNULL, in which case an error is raised if\nthe PDO entry does not byte-align."]
    pub bit_position: *mut ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_pdo_entry_reg_t"][::std::mem::size_of::<ec_pdo_entry_reg_t>() - 32usize];
    ["Alignment of ec_pdo_entry_reg_t"][::std::mem::align_of::<ec_pdo_entry_reg_t>() - 8usize];
    ["Offset of field: ec_pdo_entry_reg_t::alias"]
        [::std::mem::offset_of!(ec_pdo_entry_reg_t, alias) - 0usize];
    ["Offset of field: ec_pdo_entry_reg_t::position"]
        [::std::mem::offset_of!(ec_pdo_entry_reg_t, position) - 2usize];
    ["Offset of field: ec_pdo_entry_reg_t::vendor_id"]
        [::std::mem::offset_of!(ec_pdo_entry_reg_t, vendor_id) - 4usize];
    ["Offset of field: ec_pdo_entry_reg_t::product_code"]
        [::std::mem::offset_of!(ec_pdo_entry_reg_t, product_code) - 8usize];
    ["Offset of field: ec_pdo_entry_reg_t::index"]
        [::std::mem::offset_of!(ec_pdo_entry_reg_t, index) - 12usize];
    ["Offset of field: ec_pdo_entry_reg_t::subindex"]
        [::std::mem::offset_of!(ec_pdo_entry_reg_t, subindex) - 14usize];
    ["Offset of field: ec_pdo_entry_reg_t::offset"]
        [::std::mem::offset_of!(ec_pdo_entry_reg_t, offset) - 16usize];
    ["Offset of field: ec_pdo_entry_reg_t::bit_position"]
        [::std::mem::offset_of!(ec_pdo_entry_reg_t, bit_position) - 24usize];
};
impl Default for ec_pdo_entry_reg_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " Request state.\n\n This is used as return type for ecrt_sdo_request_state() and\n ecrt_voe_handler_state()."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ec_request_state_t {
    #[doc = "< Not requested."]
    EC_REQUEST_UNUSED = 0,
    #[doc = "< Request is being processed."]
    EC_REQUEST_BUSY = 1,
    #[doc = "< Request was processed successfully."]
    EC_REQUEST_SUCCESS = 2,
    #[doc = "< Request processing failed."]
    EC_REQUEST_ERROR = 3,
}
#[repr(u32)]
#[doc = " Application-layer state."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ec_al_state_t {
    #[doc = "< Init."]
    EC_AL_STATE_INIT = 1,
    #[doc = "< Pre-operational."]
    EC_AL_STATE_PREOP = 2,
    #[doc = "< Safe-operational."]
    EC_AL_STATE_SAFEOP = 4,
    #[doc = "< Operational."]
    EC_AL_STATE_OP = 8,
}
unsafe extern "C" {
    #[doc = " Returns the version magic of the realtime interface.\n\n \\apiusage{master_any,rt_safe}\n\n \\return Value of ECRT_VERSION_MAGIC() at EtherCAT master compile time."]
    pub fn ecrt_version_magic() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Requests an EtherCAT master for realtime operation.\n\n Before an application can access an EtherCAT master, it has to reserve one\n for exclusive use.\n\n In userspace, this is a convenience function for ecrt_open_master() and\n ecrt_master_reserve().\n\n This function has to be the first function an application has to call to\n use EtherCAT. The function takes the index of the master as its argument.\n The first master has index 0, the n-th master has index n - 1. The number\n of masters has to be specified when loading the master module.\n\n \\apiusage{master_idle,blocking}\n\n \\return Pointer to the reserved master, otherwise \\a NULL."]
    pub fn ecrt_request_master(master_index: ::std::os::raw::c_uint) -> *mut ec_master_t;
}
unsafe extern "C" {
    #[doc = " Opens an EtherCAT master for userspace access.\n\n This function has to be the first function an application has to call to\n use EtherCAT. The function takes the index of the master as its argument.\n The first master has index 0, the n-th master has index n - 1. The number\n of masters has to be specified when loading the master module.\n\n For convenience, the function ecrt_request_master() can be used.\n\n \\apiusage{master_idle,blocking}\n\n \\return Pointer to the opened master, otherwise \\a NULL."]
    pub fn ecrt_open_master(master_index: ::std::os::raw::c_uint) -> *mut ec_master_t;
}
unsafe extern "C" {
    #[doc = " Releases a requested EtherCAT master.\n\n After use, a master it has to be released to make it available for other\n applications.\n\n This method frees all created data structures. It should not be called in\n realtime context.\n\n If the master was activated, ecrt_master_deactivate() is called internally.\n\n \\apiusage{master_any,blocking}"]
    pub fn ecrt_release_master(master: *mut ec_master_t);
}
unsafe extern "C" {
    #[doc = " Reserves an EtherCAT master for realtime operation.\n\n Before an application can use PDO/domain registration functions or SDO\n request functions on the master, it has to reserve one for exclusive use.\n\n \\apiusage{master_idle,blocking}\n\n \\return 0 in case of success, else < 0"]
    pub fn ecrt_master_reserve(master: *mut ec_master_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Creates a new process data domain.\n\n For process data exchange, at least one process data domain is needed.\n This method creates a new process data domain and returns a pointer to the\n new domain object. This object can be used for registering PDOs and\n exchanging them in cyclic operation.\n\n This method allocates memory and should be called in non-realtime context\n before ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\return Pointer to the new domain on success, else NULL."]
    pub fn ecrt_master_create_domain(master: *mut ec_master_t) -> *mut ec_domain_t;
}
unsafe extern "C" {
    #[doc = " Obtains a slave configuration.\n\n Creates a slave configuration object for the given \\a alias and \\a position\n tuple and returns it. If a configuration with the same \\a alias and \\a\n position already exists, it will be re-used. In the latter case, the given\n vendor ID and product code are compared to the stored ones. On mismatch, an\n error message is raised and the function returns \\a NULL.\n\n Slaves are addressed with the \\a alias and \\a position parameters.\n - If \\a alias is zero, \\a position is interpreted as the desired slave's\n   ring position.\n - If \\a alias is non-zero, it matches a slave with the given alias. In this\n   case, \\a position is interpreted as ring offset, starting from the\n   aliased slave, so a position of zero means the aliased slave itself and a\n   positive value matches the n-th slave behind the aliased one.\n\n If the slave with the given address is found during the configuration,\n its vendor ID and product code are matched against the given value. On\n mismatch, the slave is not configured and an error message is raised.\n\n If different slave configurations are pointing to the same slave during\n configuration, a warning is raised and only the first configuration is\n applied.\n\n This method allocates memory and should be called in non-realtime context\n before ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\retval >0 Pointer to the slave configuration structure.\n \\retval NULL in the error case."]
    pub fn ecrt_master_slave_config(
        master: *mut ec_master_t,
        alias: u16,
        position: u16,
        vendor_id: u32,
        product_code: u32,
    ) -> *mut ec_slave_config_t;
}
unsafe extern "C" {
    #[doc = " Selects the reference clock for distributed clocks.\n\n If this method is not called for a certain master, or if the slave\n configuration pointer is NULL, then the first slave with DC functionality\n will provide the reference clock.\n\n \\apiusage{master_idle,blocking}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_master_select_reference_clock(
        master: *mut ec_master_t,
        sc: *mut ec_slave_config_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Obtains master information.\n\n No memory is allocated on the heap in this function.\n\n \\apiusage{master_any,rt_safe}\n\n \\attention The pointer to this structure must point to a valid variable.\n\n \\return 0 in case of success, else < 0"]
    pub fn ecrt_master(
        master: *mut ec_master_t,
        master_info: *mut ec_master_info_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Obtains network scan progress information.\n\n No memory is allocated on the heap in this function.\n\n \\apiusage{master_any,rt_safe}\n\n \\attention The pointer to this structure must point to a valid variable.\n\n \\return 0 in case of success, else < 0"]
    pub fn ecrt_master_scan_progress(
        master: *mut ec_master_t,
        progress: *mut ec_master_scan_progress_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Obtains slave information.\n\n Tries to find the slave with the given ring position. The obtained\n information is stored in a structure. No memory is allocated on the heap in\n this function.\n\n \\apiusage{master_any,blocking}\n\n \\attention The pointer to this structure must point to a valid variable.\n\n \\return 0 in case of success, else < 0"]
    pub fn ecrt_master_get_slave(
        master: *mut ec_master_t,
        slave_position: u16,
        slave_info: *mut ec_slave_info_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the proposed configuration of a slave's sync manager.\n\n Fills a given ec_sync_info_t structure with the attributes of a sync\n manager. The \\a pdos field of the return value is left empty. Use\n ecrt_master_get_pdo() to get the PDO information.\n\n \\apiusage{master_any,blocking}\n\n \\return zero on success, else non-zero"]
    pub fn ecrt_master_get_sync_manager(
        master: *mut ec_master_t,
        slave_position: u16,
        sync_index: u8,
        sync: *mut ec_sync_info_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns information about a currently assigned PDO.\n\n Fills a given ec_pdo_info_t structure with the attributes of a currently\n assigned PDO of the given sync manager. The \\a entries field of the return\n value is left empty. Use ecrt_master_get_pdo_entry() to get the PDO\n entry information.\n\n \\apiusage{master_any,blocking}\n\n \\retval zero on success, else non-zero"]
    pub fn ecrt_master_get_pdo(
        master: *mut ec_master_t,
        slave_position: u16,
        sync_index: u8,
        pos: u16,
        pdo: *mut ec_pdo_info_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns information about a currently mapped PDO entry.\n\n Fills a given ec_pdo_entry_info_t structure with the attributes of a\n currently mapped PDO entry of the given PDO.\n\n \\apiusage{master_any,blocking}\n\n \\retval zero on success, else non-zero"]
    pub fn ecrt_master_get_pdo_entry(
        master: *mut ec_master_t,
        slave_position: u16,
        sync_index: u8,
        pdo_pos: u16,
        entry_pos: u16,
        entry: *mut ec_pdo_entry_info_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Executes an SDO download request to write data to a slave.\n\n This request is processed by the master state machine. This method blocks,\n until the request has been processed and may not be called in realtime\n context.\n\n \\apiusage{master_any,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_master_sdo_download(
        master: *mut ec_master_t,
        slave_position: u16,
        index: u16,
        subindex: u8,
        data: *const u8,
        data_size: usize,
        abort_code: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Executes an SDO download request to write data to a slave via complete\n access.\n\n This request is processed by the master state machine. This method blocks,\n until the request has been processed and may not be called in realtime\n context.\n\n \\apiusage{master_any,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_master_sdo_download_complete(
        master: *mut ec_master_t,
        slave_position: u16,
        index: u16,
        data: *const u8,
        data_size: usize,
        abort_code: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Executes an SDO upload request to read data from a slave.\n\n This request is processed by the master state machine. This method blocks,\n until the request has been processed and may not be called in realtime\n context.\n\n \\apiusage{master_any,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_master_sdo_upload(
        master: *mut ec_master_t,
        slave_position: u16,
        index: u16,
        subindex: u8,
        target: *mut u8,
        target_size: usize,
        result_size: *mut usize,
        abort_code: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Executes an SoE write request.\n\n Starts writing an IDN and blocks until the request was processed, or an\n error occurred.\n\n \\apiusage{master_any,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_master_write_idn(
        master: *mut ec_master_t,
        slave_position: u16,
        drive_no: u8,
        idn: u16,
        data: *const u8,
        data_size: usize,
        error_code: *mut u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Executes an SoE read request.\n\n Starts reading an IDN and blocks until the request was processed, or an\n error occurred.\n\n \\apiusage{master_any,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_master_read_idn(
        master: *mut ec_master_t,
        slave_position: u16,
        drive_no: u8,
        idn: u16,
        target: *mut u8,
        target_size: usize,
        result_size: *mut usize,
        error_code: *mut u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Finishes the configuration phase and prepares for cyclic operation.\n\n This function tells the master that the configuration phase is finished and\n the realtime operation will begin. The function allocates internal memory\n for the domains and calculates the logical FMMU addresses for domain\n members. It tells the master state machine that the configuration is\n now to be applied to the network.\n\n \\apiusage{master_idle,blocking}\n\n \\attention After this function has been called, the realtime application is\n in charge of cyclically calling ecrt_master_send() and\n ecrt_master_receive() to ensure network communication. Before calling this\n function, the master thread is responsible for that, so these functions may\n not be called! The method itself allocates memory and should not be called\n in realtime context.\n\n \\return 0 in case of success, else < 0"]
    pub fn ecrt_master_activate(master: *mut ec_master_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Deactivates the master.\n\n Removes the master configuration. All objects created by\n ecrt_master_create_domain(), ecrt_master_slave_config(), ecrt_domain_data()\n ecrt_slave_config_create_sdo_request() and\n ecrt_slave_config_create_voe_handler() are freed, so pointers to them\n become invalid.\n\n \\apiusage{master_op,blocking}\n\n This method should not be called in realtime context.\n \\return 0 on success, otherwise negative error code.\n \\retval 0 Success.\n \\retval -EINVAL Master has not been activated before."]
    pub fn ecrt_master_deactivate(master: *mut ec_master_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set interval between calls to ecrt_master_send().\n\n This information helps the master to decide, how much data can be appended\n to a frame by the master state machine. When the master is configured with\n --enable-hrtimers, this is used to calculate the scheduling of the master\n thread.\n\n \\apiusage{master_idle,blocking}\n\n \\retval 0 on success.\n \\retval <0 Error code."]
    pub fn ecrt_master_set_send_interval(
        master: *mut ec_master_t,
        send_interval: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sends all datagrams in the queue.\n\n This method takes all datagrams, that have been queued for transmission,\n puts them into frames, and passes them to the Ethernet device for sending.\n\n Has to be called cyclically by the application after ecrt_master_activate()\n has returned.\n\n \\apiusage{master_op,rt_safe}\n\n \\return Zero on success, otherwise negative error code."]
    pub fn ecrt_master_send(master: *mut ec_master_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Fetches received frames from the hardware and processes the datagrams.\n\n Queries the network device for received frames by calling the interrupt\n service routine. Extracts received datagrams and dispatches the results to\n the datagram objects in the queue. Received datagrams, and the ones that\n timed out, will be marked, and dequeued.\n\n Has to be called cyclically by the realtime application after\n ecrt_master_activate() has returned.\n\n \\apiusage{master_op,rt_safe}\n\n \\return Zero on success, otherwise negative error code."]
    pub fn ecrt_master_receive(master: *mut ec_master_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reads the current master state.\n\n Stores the master state information in the given \\a state structure.\n\n This method returns a global state. For the link-specific states in a\n redundant network topology, use the ecrt_master_link_state() method.\n\n \\apiusage{master_any,rt_safe}\n\n \\return Zero on success, otherwise negative error code."]
    pub fn ecrt_master_state(
        master: *const ec_master_t,
        state: *mut ec_master_state_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reads the current state of a redundant link.\n\n Stores the link state information in the given \\a state structure.\n\n \\apiusage{master_any,rt_safe}\n\n \\return Zero on success, otherwise negative error code."]
    pub fn ecrt_master_link_state(
        master: *const ec_master_t,
        dev_idx: ::std::os::raw::c_uint,
        state: *mut ec_master_link_state_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sets the application time.\n\n The master has to know the application's time when operating slaves with\n distributed clocks. The time is not incremented by the master itself, so\n this method has to be called cyclically.\n\n \\attention The time passed to this method is used to calculate the phase of\n the slaves' SYNC0/1 interrupts. It should be called constantly at the same\n point of the realtime cycle. So it is recommended to call it at the start\n of the calculations to avoid deviancies due to changing execution times.\n Avoid calling this method before the realtime cycle is established.\n\n The time is used when setting the slaves' <tt>System Time Offset</tt> and\n <tt>Cyclic Operation Start Time</tt> registers and when synchronizing the\n DC reference clock to the application time via\n ecrt_master_sync_reference_clock().\n\n The time is defined as nanoseconds from 2000-01-01 00:00. Converting an\n epoch time can be done with the EC_TIMEVAL2NANO() macro, but is not\n necessary, since the absolute value is not of any interest.\n\n \\apiusage{master_op,rt_safe}\n\n \\return Zero on success, otherwise negative error code."]
    pub fn ecrt_master_application_time(
        master: *mut ec_master_t,
        app_time: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Queues the DC reference clock drift compensation datagram for sending.\n\n The reference clock will by synchronized to the application time provided\n by the last call off ecrt_master_application_time().\n\n \\apiusage{master_op,rt_safe}\n\n \\return Zero on success, otherwise negative error code.\n \\retval 0 Success.\n \\retval -ENXIO No reference clock found."]
    pub fn ecrt_master_sync_reference_clock(master: *mut ec_master_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Queues the DC reference clock drift compensation datagram for sending.\n\n The reference clock will by synchronized to the time passed in the\n sync_time parameter.\n\n Has to be called by the application after ecrt_master_activate()\n has returned.\n\n \\apiusage{master_op,rt_safe}\n\n \\return Zero on success, otherwise negative error code.\n \\retval 0 Success.\n \\retval -ENXIO No reference clock found."]
    pub fn ecrt_master_sync_reference_clock_to(
        master: *mut ec_master_t,
        sync_time: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Queues the DC clock drift compensation datagram for sending.\n\n All slave clocks synchronized to the reference clock.\n\n Has to be called by the application after ecrt_master_activate()\n has returned.\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code.\n \\retval 0 Success.\n \\retval -ENXIO No reference clock found."]
    pub fn ecrt_master_sync_slave_clocks(master: *mut ec_master_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the lower 32 bit of the reference clock system time.\n\n This method can be used to synchronize the master to the reference clock.\n\n The reference clock system time is queried via the\n ecrt_master_sync_slave_clocks() method, that reads the system time of the\n reference clock and writes it to the slave clocks (so be sure to call it\n cyclically to get valid data).\n\n \\attention The returned time is the system time of the reference clock\n minus the transmission delay of the reference clock.\n\n Calling this method makes only sense in realtime context (after master\n activation), when the ecrt_master_sync_slave_clocks() method is called\n cyclically.\n\n \\apiusage{master_op,rt_safe}\n\n \\retval 0 success, system time was written into \\a time.\n \\retval -ENXIO No reference clock found.\n \\retval -EIO Slave synchronization datagram was not received."]
    pub fn ecrt_master_reference_clock_time(
        master: *const ec_master_t,
        time: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Queues the DC synchrony monitoring datagram for sending.\n\n The datagram broadcast-reads all \"System time difference\" registers (\\a\n 0x092c) to get an upper estimation of the DC synchrony. The result can be\n checked with the ecrt_master_sync_monitor_process() method.\n\n \\apiusage{master_op,rt_safe}\n\n \\return Zero on success, otherwise a negative error code."]
    pub fn ecrt_master_sync_monitor_queue(master: *mut ec_master_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Processes the DC synchrony monitoring datagram.\n\n If the sync monitoring datagram was sent before with\n ecrt_master_sync_monitor_queue(), the result can be queried with this\n method.\n\n \\apiusage{master_op,rt_safe}\n\n \\return Upper estimation of the maximum time difference in ns, -1 on error.\n \\retval (uint32_t)-1 Error."]
    pub fn ecrt_master_sync_monitor_process(master: *const ec_master_t) -> u32;
}
unsafe extern "C" {
    #[doc = " Retry configuring slaves.\n\n Via this method, the application can tell the master to bring all slaves to\n OP state. In general, this is not necessary, because it is automatically\n done by the master. But with special slaves, that can be reconfigured by\n the vendor during runtime, it can be useful.\n\n Calling this method only makes sense in realtime context (after\n activation), because slaves will not be configured before.\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_master_reset(master: *mut ec_master_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configure a sync manager.\n\n Sets the direction of a sync manager. This overrides the direction bits\n from the default control register from SII.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\return zero on success, else non-zero"]
    pub fn ecrt_slave_config_sync_manager(
        sc: *mut ec_slave_config_t,
        sync_index: u8,
        direction: ec_direction_t,
        watchdog_mode: ec_watchdog_mode_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configure a slave's watchdog times.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_slave_config_watchdog(
        sc: *mut ec_slave_config_t,
        watchdog_divider: u16,
        watchdog_intervals: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a PDO to a sync manager's PDO assignment.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\see ecrt_slave_config_pdos()\n \\return zero on success, else non-zero"]
    pub fn ecrt_slave_config_pdo_assign_add(
        sc: *mut ec_slave_config_t,
        sync_index: u8,
        index: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Clear a sync manager's PDO assignment.\n\n This can be called before assigning PDOs via\n ecrt_slave_config_pdo_assign_add(), to clear the default assignment of a\n sync manager.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\see ecrt_slave_config_pdos()\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_slave_config_pdo_assign_clear(
        sc: *mut ec_slave_config_t,
        sync_index: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a PDO entry to the given PDO's mapping.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\see ecrt_slave_config_pdos()\n \\return zero on success, else non-zero"]
    pub fn ecrt_slave_config_pdo_mapping_add(
        sc: *mut ec_slave_config_t,
        pdo_index: u16,
        entry_index: u16,
        entry_subindex: u8,
        entry_bit_length: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Clear the mapping of a given PDO.\n\n This can be called before mapping PDO entries via\n ecrt_slave_config_pdo_mapping_add(), to clear the default mapping.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\see ecrt_slave_config_pdos()\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_slave_config_pdo_mapping_clear(
        sc: *mut ec_slave_config_t,
        pdo_index: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Specify a complete PDO configuration.\n\n This function is a convenience wrapper for the functions\n ecrt_slave_config_sync_manager(), ecrt_slave_config_pdo_assign_clear(),\n ecrt_slave_config_pdo_assign_add(), ecrt_slave_config_pdo_mapping_clear()\n and ecrt_slave_config_pdo_mapping_add(), that are better suitable for\n automatic code generation.\n\n The following example shows, how to specify a complete configuration,\n including the PDO mappings. With this information, the master is able to\n reserve the complete process data, even if the slave is not present at\n configuration time:\n\n \\code\n ec_pdo_entry_info_t el3162_channel1[] = {\n     {0x3101, 1,  8}, // status\n     {0x3101, 2, 16}  // value\n };\n\n ec_pdo_entry_info_t el3162_channel2[] = {\n     {0x3102, 1,  8}, // status\n     {0x3102, 2, 16}  // value\n };\n\n ec_pdo_info_t el3162_pdos[] = {\n     {0x1A00, 2, el3162_channel1},\n     {0x1A01, 2, el3162_channel2}\n };\n\n ec_sync_info_t el3162_syncs[] = {\n     {2, EC_DIR_OUTPUT},\n     {3, EC_DIR_INPUT, 2, el3162_pdos},\n     {0xff}\n };\n\n if (ecrt_slave_config_pdos(sc_ana_in, EC_END, el3162_syncs)) {\n     // handle error\n }\n \\endcode\n\n The next example shows, how to configure the PDO assignment only. The\n entries for each assigned PDO are taken from the PDO's default mapping.\n Please note, that PDO entry registration will fail, if the PDO\n configuration is left empty and the slave is offline.\n\n \\code\n ec_pdo_info_t pdos[] = {\n     {0x1600}, // Channel 1\n     {0x1601}  // Channel 2\n };\n\n ec_sync_info_t syncs[] = {\n     {3, EC_DIR_INPUT, 2, pdos},\n };\n\n if (ecrt_slave_config_pdos(slave_config_ana_in, 1, syncs)) {\n     // handle error\n }\n \\endcode\n\n Processing of \\a syncs will stop, if\n - the number of processed items reaches \\a n_syncs, or\n - the \\a index member of an ec_sync_info_t item is 0xff. In this case,\n   \\a n_syncs should set to a number greater than the number of list items;\n   using EC_END is recommended.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\return zero on success, else non-zero"]
    pub fn ecrt_slave_config_pdos(
        sc: *mut ec_slave_config_t,
        n_syncs: ::std::os::raw::c_uint,
        syncs: *const ec_sync_info_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Registers a PDO entry for process data exchange in a domain.\n\n Searches the assigned PDOs for the given PDO entry. An error is raised, if\n the given entry is not mapped. Otherwise, the corresponding sync manager\n and FMMU configurations are provided for slave configuration and the\n respective sync manager's assigned PDOs are appended to the given domain,\n if not already done. The offset of the requested PDO entry's data inside\n the domain's process data is returned. Optionally, the PDO entry bit\n position (0-7) can be retrieved via the \\a bit_position output parameter.\n This pointer may be \\a NULL, in this case an error is raised if the PDO\n entry does not byte-align.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\retval >=0 Success: Offset of the PDO entry's process data.\n \\retval  <0 Error code."]
    pub fn ecrt_slave_config_reg_pdo_entry(
        sc: *mut ec_slave_config_t,
        entry_index: u16,
        entry_subindex: u8,
        domain: *mut ec_domain_t,
        bit_position: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Registers a PDO entry using its position.\n\n Similar to ecrt_slave_config_reg_pdo_entry(), but not using PDO indices but\n offsets in the PDO mapping, because PDO entry indices may not be unique\n inside a slave's PDO mapping. An error is raised, if\n one of the given positions is out of range.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\retval >=0 Success: Offset of the PDO entry's process data.\n \\retval  <0 Error code."]
    pub fn ecrt_slave_config_reg_pdo_entry_pos(
        sc: *mut ec_slave_config_t,
        sync_index: u8,
        pdo_pos: ::std::os::raw::c_uint,
        entry_pos: ::std::os::raw::c_uint,
        domain: *mut ec_domain_t,
        bit_position: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configure distributed clocks.\n\n Sets the AssignActivate word and the cycle and shift times for the sync\n signals.\n\n The AssignActivate word is vendor-specific and can be taken from the XML\n device description file (Device -> Dc -> AssignActivate). Set this to zero,\n if the slave shall be operated without distributed clocks (default).\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\attention The \\a sync1_shift time is ignored.\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_slave_config_dc(
        sc: *mut ec_slave_config_t,
        assign_activate: u16,
        sync0_cycle: u32,
        sync0_shift: i32,
        sync1_cycle: u32,
        sync1_shift: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add an SDO configuration.\n\n An SDO configuration is stored in the slave configuration object and is\n downloaded to the slave whenever the slave is being configured by the\n master. This usually happens once on master activation, but can be repeated\n subsequently, for example after the slave's power supply failed.\n\n \\attention The SDOs for PDO assignment (\\p 0x1C10 - \\p 0x1C2F) and PDO\n mapping (\\p 0x1600 - \\p 0x17FF and \\p 0x1A00 - \\p 0x1BFF) should not be\n configured with this function, because they are part of the slave\n configuration done by the master. Please use ecrt_slave_config_pdos() and\n friends instead.\n\n This is the generic function for adding an SDO configuration. Please note\n that the this function does not do any endianness correction. If\n datatype-specific functions are needed (that automatically correct the\n endianness), have a look at ecrt_slave_config_sdo8(),\n ecrt_slave_config_sdo16() and ecrt_slave_config_sdo32().\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_sdo(
        sc: *mut ec_slave_config_t,
        index: u16,
        subindex: u8,
        data: *const u8,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a configuration value for an 8-bit SDO.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\see ecrt_slave_config_sdo().\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_sdo8(
        sc: *mut ec_slave_config_t,
        sdo_index: u16,
        sdo_subindex: u8,
        value: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a configuration value for a 16-bit SDO.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\see ecrt_slave_config_sdo().\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_sdo16(
        sc: *mut ec_slave_config_t,
        sdo_index: u16,
        sdo_subindex: u8,
        value: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a configuration value for a 32-bit SDO.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\see ecrt_slave_config_sdo().\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_sdo32(
        sc: *mut ec_slave_config_t,
        sdo_index: u16,
        sdo_subindex: u8,
        value: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add configuration data for a complete SDO.\n\n The SDO data are transferred via CompleteAccess. Data for the first\n subindex (0) have to be included.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\see ecrt_slave_config_sdo().\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_complete_sdo(
        sc: *mut ec_slave_config_t,
        index: u16,
        data: *const u8,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the size of the CoE emergency ring buffer.\n\n The initial size is zero, so all messages will be dropped. This method can\n be called even after master activation, but it will clear the ring buffer!\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\return 0 on success, or negative error code."]
    pub fn ecrt_slave_config_emerg_size(
        sc: *mut ec_slave_config_t,
        elements: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read and remove one record from the CoE emergency ring buffer.\n\n A record consists of 8 bytes:\n\n Byte 0-1: Error code (little endian)\n Byte   2: Error register\n Byte 3-7: Data\n\n Calling this method makes only sense in realtime context (after master\n activation).\n\n \\return 0 on success (record popped), or negative error code (i. e.\n -ENOENT, if ring is empty).\n\n \\apiusage{master_op,any_context}"]
    pub fn ecrt_slave_config_emerg_pop(
        sc: *mut ec_slave_config_t,
        target: *mut u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Clears CoE emergency ring buffer and the overrun counter.\n\n Calling this method makes only sense in realtime context (after master\n activation).\n\n \\apiusage{master_op,any_context}\n\n \\return 0 on success, or negative error code.\n"]
    pub fn ecrt_slave_config_emerg_clear(sc: *mut ec_slave_config_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read the number of CoE emergency overruns.\n\n The overrun counter will be incremented when a CoE emergency message could\n not be stored in the ring buffer and had to be dropped. Call\n ecrt_slave_config_emerg_clear() to reset the counter.\n\n Calling this method makes only sense in realtime context (after master\n activation).\n\n \\apiusage{master_op,any_context}\n\n \\return Number of overruns since last clear, or negative error code.\n"]
    pub fn ecrt_slave_config_emerg_overruns(sc: *const ec_slave_config_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create an SDO request to exchange SDOs during realtime operation.\n\n The created SDO request object is freed automatically when the master is\n released.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\return New SDO request, or NULL on error."]
    pub fn ecrt_slave_config_create_sdo_request(
        sc: *mut ec_slave_config_t,
        index: u16,
        subindex: u8,
        size: usize,
    ) -> *mut ec_sdo_request_t;
}
unsafe extern "C" {
    #[doc = " Create an SoE request to exchange SoE IDNs during realtime operation.\n\n The created SoE request object is freed automatically when the master is\n released.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\return New SoE request, or NULL on error."]
    pub fn ecrt_slave_config_create_soe_request(
        sc: *mut ec_slave_config_t,
        drive_no: u8,
        idn: u16,
        size: usize,
    ) -> *mut ec_soe_request_t;
}
unsafe extern "C" {
    #[doc = " Create an VoE handler to exchange vendor-specific data during realtime\n operation.\n\n The number of VoE handlers per slave configuration is not limited, but\n usually it is enough to create one for sending and one for receiving, if\n both can be done simultaneously.\n\n The created VoE handler object is freed automatically when the master is\n released.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\return New VoE handler, or NULL on error."]
    pub fn ecrt_slave_config_create_voe_handler(
        sc: *mut ec_slave_config_t,
        size: usize,
    ) -> *mut ec_voe_handler_t;
}
unsafe extern "C" {
    #[doc = " Create a register request to exchange EtherCAT register contents during\n realtime operation.\n\n This interface should not be used to take over master functionality,\n instead it is intended for debugging and monitoring reasons.\n\n The created register request object is freed automatically when the master\n is released.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\return New register request, or NULL on error."]
    pub fn ecrt_slave_config_create_reg_request(
        sc: *mut ec_slave_config_t,
        size: usize,
    ) -> *mut ec_reg_request_t;
}
unsafe extern "C" {
    #[doc = " Outputs the state of the slave configuration.\n\n Stores the state information in the given \\a state structure. The state\n information is updated by the master state machine, so it may take a few\n cycles, until it changes.\n\n \\attention If the state of process data exchange shall be monitored in\n realtime, ecrt_domain_state() should be used.\n\n \\apiusage{master_op,rt_safe}\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_state(
        sc: *const ec_slave_config_t,
        state: *mut ec_slave_config_state_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add an SoE IDN configuration.\n\n A configuration for a Sercos-over-EtherCAT IDN is stored in the slave\n configuration object and is written to the slave whenever the slave is\n being configured by the master. This usually happens once on master\n activation, but can be repeated subsequently, for example after the slave's\n power supply failed.\n\n The \\a idn parameter can be separated into several sections:\n  - Bit 15: Standard data (0) or Product data (1)\n  - Bit 14 - 12: Parameter set (0 - 7)\n  - Bit 11 - 0: Data block number (0 - 4095)\n\n Please note that the this function does not do any endianness correction.\n Multi-byte data have to be passed in EtherCAT endianness (little-endian).\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_idn(
        sc: *mut ec_slave_config_t,
        drive_no: u8,
        idn: u16,
        state: ec_al_state_t,
        data: *const u8,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Adds a feature flag to a slave configuration.\n\n Feature flags are a generic way to configure slave-specific behavior.\n\n Multiple calls with the same slave configuration and key will overwrite the\n configuration.\n\n The following flags may be available:\n - AssignToPdi: Zero (default) keeps the slave information interface (SII)\n   assigned to EtherCAT (except during transition to PREOP). Non-zero\n   assigns the SII to the slave controller side before going to PREOP and\n   leaves it there until a write command happens.\n - WaitBeforeSAFEOPms: Number of milliseconds to wait before commanding the\n   transition from PREOP to SAFEOP. This can be used as a workaround for\n   slaves that need a little time to initialize.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_flag(
        sc: *mut ec_slave_config_t,
        key: *const ::std::os::raw::c_char,
        value: i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sets the link/MAC address for Ethernet-over-EtherCAT (EoE) operation.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n The MAC address is stored in the slave configuration object and will be\n written to the slave during the configuration process.\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_eoe_mac_address(
        sc: *mut ec_slave_config_t,
        mac_address: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sets the IP address for Ethernet-over-EtherCAT (EoE) operation.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n The IP address is stored in the slave configuration object and will be\n written to the slave during the configuration process.\n\n The IP address is passed by-value as a `struct in_addr`. This structure\n contains the 32-bit IPv4 address in network byte order (big endian).\n\n A string-represented IPv4 address can be converted to a `struct in_addr`\n for example via the POSIX function `inet_pton()` (see man 3 inet_pton):\n\n \\code{.c}\n     #include <arpa/inet.h>\n     struct in_addr addr;\n     if (inet_aton(\"192.168.0.1\", &addr) == 0) {\n         fprintf(stderr, \"Failed to convert IP address.\\n\");\n         return -1;\n     }\n     if (ecrt_slave_config_eoe_ip_address(sc, addr)) {\n         fprintf(stderr, \"Failed to set IP address.\\n\");\n         return -1;\n     }\n \\endcode\n\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_eoe_ip_address(
        sc: *mut ec_slave_config_t,
        ip_address: in_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sets the subnet mask for Ethernet-over-EtherCAT (EoE) operation.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n The subnet mask is stored in the slave configuration object and will be\n written to the slave during the configuration process.\n\n The subnet mask is passed by-value as a `struct in_addr`. This structure\n contains the 32-bit mask in network byte order (big endian).\n\n See ecrt_slave_config_eoe_ip_address() on how to convert string-coded masks\n to `struct in_addr`.\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_eoe_subnet_mask(
        sc: *mut ec_slave_config_t,
        subnet_mask: in_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sets the gateway address for Ethernet-over-EtherCAT (EoE) operation.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n The gateway address is stored in the slave configuration object and will be\n written to the slave during the configuration process.\n\n The address is passed by-value as a `struct in_addr`. This structure\n contains the 32-bit IPv4 address in network byte order (big endian).\n\n See ecrt_slave_config_eoe_ip_address() on how to convert string-coded IPv4\n addresses to `struct in_addr`.\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_eoe_default_gateway(
        sc: *mut ec_slave_config_t,
        gateway_address: in_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sets the IPv4 address of the DNS server for Ethernet-over-EtherCAT (EoE)\n operation.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n The DNS server address is stored in the slave configuration object and will\n be written to the slave during the configuration process.\n\n The address is passed by-value as a `struct in_addr`. This structure\n contains the 32-bit IPv4 address in network byte order (big endian).\n\n See ecrt_slave_config_eoe_ip_address() on how to convert string-coded IPv4\n addresses to `struct in_addr`.\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_eoe_dns_address(
        sc: *mut ec_slave_config_t,
        dns_address: in_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sets the host name for Ethernet-over-EtherCAT (EoE) operation.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n The host name is stored in the slave configuration object and will\n be written to the slave during the configuration process.\n\n The maximum size of the host name is 32 bytes (including the zero\n terminator).\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_eoe_hostname(
        sc: *mut ec_slave_config_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sets the application-layer state transition timeout in ms.\n\n Change the maximum allowed time for a slave to make an application-layer\n state transition for the given state transition (for example from PREOP to\n SAFEOP). The default values are defined in ETG.2000.\n\n A timeout value of zero ms will restore the default value.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\apiusage{master_idle,blocking}\n\n \\retval  0 Success.\n \\retval <0 Error code."]
    pub fn ecrt_slave_config_state_timeout(
        sc: *mut ec_slave_config_t,
        from_state: ec_al_state_t,
        to_state: ec_al_state_t,
        timeout_ms: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Registers a bunch of PDO entries for a domain.\n\n This method has to be called in non-realtime context before\n ecrt_master_activate().\n\n \\see ecrt_slave_config_reg_pdo_entry()\n\n \\attention The registration array has to be terminated with an empty\n            structure, or one with the \\a index field set to zero!\n\n \\apiusage{master_idle,blocking}\n\n \\return 0 on success, else non-zero."]
    pub fn ecrt_domain_reg_pdo_entry_list(
        domain: *mut ec_domain_t,
        pdo_entry_regs: *const ec_pdo_entry_reg_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the current size of the domain's process data.\n\n The domain size is calculated after master activation.\n\n \\apiusage{master_op,rt_safe}\n\n \\return Size of the process data image, or a negative error code."]
    pub fn ecrt_domain_size(domain: *const ec_domain_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the domain's process data.\n\n - In kernel context: If external memory was provided with\n ecrt_domain_external_memory(), the returned pointer will contain the\n address of that memory. Otherwise it will point to the internally allocated\n memory. In the latter case, this method may not be called before\n ecrt_master_activate().\n\n - In userspace context: This method has to be called after\n ecrt_master_activate() to get the mapped domain process data memory.\n\n \\apiusage{master_op,rt_safe}\n\n \\return Pointer to the process data memory."]
    pub fn ecrt_domain_data(domain: *const ec_domain_t) -> *mut u8;
}
unsafe extern "C" {
    #[doc = " Determines the states of the domain's datagrams.\n\n Evaluates the working counters of the received datagrams and outputs\n statistics, if necessary. This must be called after ecrt_master_receive()\n is expected to receive the domain datagrams in order to make\n ecrt_domain_state() return the result of the last process data exchange.\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_domain_process(domain: *mut ec_domain_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " (Re-)queues all domain datagrams in the master's datagram queue.\n\n Call this function to mark the domain's datagrams for exchanging at the\n next call of ecrt_master_send().\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_domain_queue(domain: *mut ec_domain_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reads the state of a domain.\n\n Stores the domain state in the given \\a state structure.\n\n Using this method, the process data exchange can be monitored in realtime.\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_domain_state(
        domain: *const ec_domain_t,
        state: *mut ec_domain_state_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the SDO index and subindex.\n\n \\attention If the SDO index and/or subindex is changed while\n ecrt_sdo_request_state() returns EC_REQUEST_BUSY, this may lead to\n unexpected results.\n\n This method is meant to be called in realtime context (after master\n activation). To initialize the SDO request, the index and subindex can be\n set via ecrt_slave_config_create_sdo_request().\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_sdo_request_index(
        req: *mut ec_sdo_request_t,
        index: u16,
        subindex: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the timeout for an SDO request.\n\n If the request cannot be processed in the specified time, if will be marked\n as failed.\n\n The timeout is permanently stored in the request object and is valid until\n the next call of this method.\n\n The timeout should be defined in non-realtime context, but can also be\n changed afterwards.\n\n \\apiusage{master_any,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_sdo_request_timeout(
        req: *mut ec_sdo_request_t,
        timeout: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Access to the SDO request's data.\n\n This function returns a pointer to the request's internal SDO data memory.\n\n - After a read operation was successful, integer data can be evaluated\n   using the EC_READ_*() macros as usual. Example:\n   \\code\n   uint16_t value = EC_READ_U16(ecrt_sdo_request_data(sdo)));\n   \\endcode\n - If a write operation shall be triggered, the data have to be written to\n   the internal memory. Use the EC_WRITE_*() macros, if you are writing\n   integer data. Be sure, that the data fit into the memory. The memory size\n   is a parameter of ecrt_slave_config_create_sdo_request().\n   \\code\n   EC_WRITE_U16(ecrt_sdo_request_data(sdo), 0xFFFF);\n   \\endcode\n\n \\attention The return value can be invalid during a read operation, because\n the internal SDO data memory could be re-allocated if the read SDO data do\n not fit inside.\n\n This method is meant to be called in realtime context (after master\n activation), but can also be used to initialize data before.\n\n \\apiusage{master_any,rt_safe}\n\n \\return Pointer to the internal SDO data memory.\n"]
    pub fn ecrt_sdo_request_data(req: *const ec_sdo_request_t) -> *mut u8;
}
unsafe extern "C" {
    #[doc = " Returns the current SDO data size.\n\n When the SDO request is created, the data size is set to the size of the\n reserved memory. After a read operation the size is set to the size of the\n read data. The size is not modified in any other situation.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_any,rt_safe}\n\n \\return SDO data size in bytes.\n"]
    pub fn ecrt_sdo_request_data_size(req: *const ec_sdo_request_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Get the current state of the SDO request.\n\n The user-space implementation fetches incoming data and stores the received\n data size in the request object, so the request is not const.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n\n \\return Request state.\n"]
    pub fn ecrt_sdo_request_state(req: *mut ec_sdo_request_t) -> ec_request_state_t;
}
unsafe extern "C" {
    #[doc = " Schedule an SDO write operation.\n\n \\attention This method may not be called while ecrt_sdo_request_state()\n returns EC_REQUEST_BUSY.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code.\n \\retval -EINVAL Invalid input data, e.g. data size == 0.\n \\retval -ENOBUFS Reserved memory in ecrt_slave_config_create_sdo_request()\n              too small."]
    pub fn ecrt_sdo_request_write(req: *mut ec_sdo_request_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Schedule an SDO read operation.\n\n \\attention This method may not be called while ecrt_sdo_request_state()\n returns EC_REQUEST_BUSY.\n\n \\attention After calling this function, the return value of\n ecrt_sdo_request_data() must be considered as invalid while\n ecrt_sdo_request_state() returns EC_REQUEST_BUSY.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_sdo_request_read(req: *mut ec_sdo_request_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the request's drive and Sercos ID numbers.\n\n \\attention If the drive number and/or IDN is changed while\n ecrt_soe_request_state() returns EC_REQUEST_BUSY, this may lead to\n unexpected results.\n\n This method is meant to be called in realtime context (after master\n activation). To initialize the SoE request, the drive_no and IDN can be\n set via ecrt_slave_config_create_soe_request().\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_soe_request_idn(
        req: *mut ec_soe_request_t,
        drive_no: u8,
        idn: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the timeout for an SoE request.\n\n If the request cannot be processed in the specified time, if will be marked\n as failed.\n\n The timeout is permanently stored in the request object and is valid until\n the next call of this method.\n\n The timeout should be defined in non-realtime context, but can also be\n changed afterwards.\n\n \\apiusage{master_any,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_soe_request_timeout(
        req: *mut ec_soe_request_t,
        timeout: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Access to the SoE request's data.\n\n This function returns a pointer to the request's internal IDN data memory.\n\n - After a read operation was successful, integer data can be evaluated\n   using the EC_READ_*() macros as usual. Example:\n   \\code\n   uint16_t value = EC_READ_U16(ecrt_soe_request_data(idn_req)));\n   \\endcode\n - If a write operation shall be triggered, the data have to be written to\n   the internal memory. Use the EC_WRITE_*() macros, if you are writing\n   integer data. Be sure, that the data fit into the memory. The memory size\n   is a parameter of ecrt_slave_config_create_soe_request().\n   \\code\n   EC_WRITE_U16(ecrt_soe_request_data(idn_req), 0xFFFF);\n   \\endcode\n\n \\attention The return value can be invalidated during a read operation,\n because the internal IDN data memory could be re-allocated if the read IDN\n data do not fit inside.\n\n This method is meant to be called in realtime context (after master\n activation), but can also be used to initialize data before.\n\n \\apiusage{master_any,rt_safe}\n\n \\return Pointer to the internal IDN data memory.\n"]
    pub fn ecrt_soe_request_data(req: *const ec_soe_request_t) -> *mut u8;
}
unsafe extern "C" {
    #[doc = " Returns the current IDN data size.\n\n When the SoE request is created, the data size is set to the size of the\n reserved memory. After a read operation the size is set to the size of the\n read data. The size is not modified in any other situation.\n\n \\apiusage{master_any,rt_safe}\n\n \\return IDN data size in bytes."]
    pub fn ecrt_soe_request_data_size(req: *const ec_soe_request_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Get the current state of the SoE request.\n\n \\return Request state.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n In the user-space implementation, the method fetches the size of the\n incoming data, so the request object is not const.\n\n \\apiusage{master_op,rt_safe}"]
    pub fn ecrt_soe_request_state(req: *mut ec_soe_request_t) -> ec_request_state_t;
}
unsafe extern "C" {
    #[doc = " Schedule an SoE IDN write operation.\n\n \\attention This method may not be called while ecrt_soe_request_state()\n returns EC_REQUEST_BUSY.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code.\n \\retval -EINVAL Invalid input data, e.g. data size == 0.\n \\retval -ENOBUFS Reserved memory in ecrt_slave_config_create_soe_request()\n              too small."]
    pub fn ecrt_soe_request_write(req: *mut ec_soe_request_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Schedule an SoE IDN read operation.\n\n \\attention This method may not be called while ecrt_soe_request_state()\n returns EC_REQUEST_BUSY.\n\n \\attention After calling this function, the return value of\n ecrt_soe_request_data() must be considered as invalid while\n ecrt_soe_request_state() returns EC_REQUEST_BUSY.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_soe_request_read(req: *mut ec_soe_request_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sets the VoE header for future send operations.\n\n A VoE message shall contain a 4-byte vendor ID, followed by a 2-byte vendor\n type at as header. These numbers can be set with this function. The values\n are valid and will be used for future send operations until the next call\n of this method.\n\n This method is meant to be called in non-realtime context (before master\n activation) to initialize the header data, but it is also safe to\n change the header later on in realtime context.\n\n \\apiusage{master_any,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_voe_handler_send_header(
        voe: *mut ec_voe_handler_t,
        vendor_id: u32,
        vendor_type: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reads the header data of a received VoE message.\n\n This method can be used to get the received VoE header information after a\n read operation has succeeded.\n\n The header information is stored at the memory given by the pointer\n parameters.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_voe_handler_received_header(
        voe: *const ec_voe_handler_t,
        vendor_id: *mut u32,
        vendor_type: *mut u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Access to the VoE handler's data.\n\n This function returns a pointer to the VoE handler's internal memory, that\n points to the actual VoE data right after the VoE header (see\n ecrt_voe_handler_send_header()).\n\n - After a read operation was successful, the memory contains the received\n   data. The size of the received data can be determined via\n   ecrt_voe_handler_data_size().\n - Before a write operation is triggered, the data have to be written to the\n   internal memory. Be sure, that the data fit into the memory. The reserved\n   memory size is a parameter of ecrt_slave_config_create_voe_handler().\n\n \\attention The returned pointer is not necessarily persistent: After a read\n operation, the internal memory may have been reallocated. This can be\n avoided by reserving enough memory via the \\a size parameter of\n ecrt_slave_config_create_voe_handler().\n\n \\apiusage{master_any,rt_safe}\n\n \\return Pointer to the internal memory."]
    pub fn ecrt_voe_handler_data(voe: *const ec_voe_handler_t) -> *mut u8;
}
unsafe extern "C" {
    #[doc = " Returns the current data size.\n\n The data size is the size of the VoE data without the header (see\n ecrt_voe_handler_send_header()).\n\n When the VoE handler is created, the data size is set to the size of the\n reserved memory. At a write operation, the data size is set to the number\n of bytes to write. After a read operation the size is set to the size of\n the read data. The size is not modified in any other situation.\n\n \\apiusage{master_any,rt_safe}\n\n \\return Data size in bytes."]
    pub fn ecrt_voe_handler_data_size(voe: *const ec_voe_handler_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Start a VoE write operation.\n\n After this function has been called, the ecrt_voe_handler_execute() method\n must be called in every realtime cycle as long as it returns\n EC_REQUEST_BUSY. No other operation may be started while the handler is\n busy.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code.\n \\retval -ENOBUFS Reserved memory in ecrt_slave_config_create_voe_handler\n                  too small."]
    pub fn ecrt_voe_handler_write(voe: *mut ec_voe_handler_t, size: usize)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start a VoE read operation.\n\n After this function has been called, the ecrt_voe_handler_execute() method\n must be called in every realtime cycle as long as it returns\n EC_REQUEST_BUSY. No other operation may be started while the handler is\n busy.\n\n The state machine queries the slave's send mailbox for new data to be send\n to the master. If no data appear within the EC_VOE_RESPONSE_TIMEOUT\n (defined in master/voe_handler.c), the operation fails.\n\n On success, the size of the read data can be determined via\n ecrt_voe_handler_data_size(), while the VoE header of the received data\n can be retrieved with ecrt_voe_handler_received_header().\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_voe_handler_read(voe: *mut ec_voe_handler_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start a VoE read operation without querying the sync manager status.\n\n After this function has been called, the ecrt_voe_handler_execute() method\n must be called in every realtime cycle as long as it returns\n EC_REQUEST_BUSY. No other operation may be started while the handler is\n busy.\n\n The state machine queries the slave by sending an empty mailbox. The slave\n fills its data to the master in this mailbox. If no data appear within the\n EC_VOE_RESPONSE_TIMEOUT (defined in master/voe_handler.c), the operation\n fails.\n\n On success, the size of the read data can be determined via\n ecrt_voe_handler_data_size(), while the VoE header of the received data\n can be retrieved with ecrt_voe_handler_received_header().\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code."]
    pub fn ecrt_voe_handler_read_nosync(voe: *mut ec_voe_handler_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Execute the handler.\n\n This method executes the VoE handler. It has to be called in every realtime\n cycle as long as it returns EC_REQUEST_BUSY.\n\n \\return Handler state.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n"]
    pub fn ecrt_voe_handler_execute(voe: *mut ec_voe_handler_t) -> ec_request_state_t;
}
unsafe extern "C" {
    #[doc = " Access to the register request's data.\n\n This function returns a pointer to the request's internal memory.\n\n - After a read operation was successful, integer data can be evaluated\n   using the EC_READ_*() macros as usual. Example:\n   \\code\n   uint16_t value = EC_READ_U16(ecrt_reg_request_data(reg_request)));\n   \\endcode\n - If a write operation shall be triggered, the data have to be written to\n   the internal memory. Use the EC_WRITE_*() macros, if you are writing\n   integer data. Be sure, that the data fit into the memory. The memory size\n   is a parameter of ecrt_slave_config_create_reg_request().\n   \\code\n   EC_WRITE_U16(ecrt_reg_request_data(reg_request), 0xFFFF);\n   \\endcode\n\n This method is meant to be called in realtime context (after master\n activation), but can also be used to initialize data before.\n\n \\apiusage{master_any,rt_safe}\n\n \\return Pointer to the internal memory.\n"]
    pub fn ecrt_reg_request_data(req: *const ec_reg_request_t) -> *mut u8;
}
unsafe extern "C" {
    #[doc = " Get the current state of the register request.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n\n \\return Request state.\n"]
    pub fn ecrt_reg_request_state(req: *const ec_reg_request_t) -> ec_request_state_t;
}
unsafe extern "C" {
    #[doc = " Schedule an register write operation.\n\n \\attention This method may not be called while ecrt_reg_request_state()\n returns EC_REQUEST_BUSY.\n\n \\attention The \\a size parameter is truncated to the size given at request\n creation.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code.\n \\retval -ENOBUFS Reserved memory in ecrt_slave_config_create_reg_request\n              too small."]
    pub fn ecrt_reg_request_write(
        req: *mut ec_reg_request_t,
        address: u16,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Schedule a register read operation.\n\n \\attention This method may not be called while ecrt_reg_request_state()\n returns EC_REQUEST_BUSY.\n\n \\attention The \\a size parameter is truncated to the size given at request\n creation.\n\n This method is meant to be called in realtime context (after master\n activation).\n\n \\apiusage{master_op,rt_safe}\n\n \\return 0 on success, otherwise negative error code.\n \\retval -ENOBUFS Reserved memory in ecrt_slave_config_create_reg_request\n              too small."]
    pub fn ecrt_reg_request_read(
        req: *mut ec_reg_request_t,
        address: u16,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read a 32-bit floating-point value from EtherCAT data.\n\n \\apiusage{master_any,rt_safe}\n\n \\param data EtherCAT data pointer\n \\return EtherCAT data value"]
    pub fn ecrt_read_real(data: *const ::std::os::raw::c_void) -> f32;
}
unsafe extern "C" {
    #[doc = " Read a 64-bit floating-point value from EtherCAT data.\n\n \\apiusage{master_any,rt_safe}\n\n \\param data EtherCAT data pointer\n \\return EtherCAT data value"]
    pub fn ecrt_read_lreal(data: *const ::std::os::raw::c_void) -> f64;
}
unsafe extern "C" {
    #[doc = " Write a 32-bit floating-point value to EtherCAT data.\n\n \\apiusage{master_any,rt_safe}\n\n \\param data EtherCAT data pointer\n \\param value new value"]
    pub fn ecrt_write_real(data: *mut ::std::os::raw::c_void, value: f32);
}
unsafe extern "C" {
    #[doc = " Write a 64-bit floating-point value to EtherCAT data.\n\n \\apiusage{master_any,rt_safe}\n\n \\param data EtherCAT data pointer\n \\param value new value"]
    pub fn ecrt_write_lreal(data: *mut ::std::os::raw::c_void, value: f64);
}
